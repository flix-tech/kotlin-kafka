[{"name":"All","description":"io.github.nomisRev.kafka.Acks.All","location":"kotlin-kafka/io.github.nomisRev.kafka/-acks/-all/index.html","searchKeys":["All","All","io.github.nomisRev.kafka.Acks.All"]},{"name":"Earliest","description":"io.github.nomisRev.kafka.AutoOffsetReset.Earliest","location":"kotlin-kafka/io.github.nomisRev.kafka/-auto-offset-reset/-earliest/index.html","searchKeys":["Earliest","Earliest","io.github.nomisRev.kafka.AutoOffsetReset.Earliest"]},{"name":"Latest","description":"io.github.nomisRev.kafka.AutoOffsetReset.Latest","location":"kotlin-kafka/io.github.nomisRev.kafka/-auto-offset-reset/-latest/index.html","searchKeys":["Latest","Latest","io.github.nomisRev.kafka.AutoOffsetReset.Latest"]},{"name":"MinusOne","description":"io.github.nomisRev.kafka.Acks.MinusOne","location":"kotlin-kafka/io.github.nomisRev.kafka/-acks/-minus-one/index.html","searchKeys":["MinusOne","MinusOne","io.github.nomisRev.kafka.Acks.MinusOne"]},{"name":"None","description":"io.github.nomisRev.kafka.AutoOffsetReset.None","location":"kotlin-kafka/io.github.nomisRev.kafka/-auto-offset-reset/-none/index.html","searchKeys":["None","None","io.github.nomisRev.kafka.AutoOffsetReset.None"]},{"name":"One","description":"io.github.nomisRev.kafka.Acks.One","location":"kotlin-kafka/io.github.nomisRev.kafka/-acks/-one/index.html","searchKeys":["One","One","io.github.nomisRev.kafka.Acks.One"]},{"name":"Zero","description":"io.github.nomisRev.kafka.Acks.Zero","location":"kotlin-kafka/io.github.nomisRev.kafka/-acks/-zero/index.html","searchKeys":["Zero","Zero","io.github.nomisRev.kafka.Acks.Zero"]},{"name":"data class AdminSettings(val bootstrapServer: String, props: Properties? = null)","description":"io.github.nomisRev.kafka.AdminSettings","location":"kotlin-kafka/io.github.nomisRev.kafka/-admin-settings/index.html","searchKeys":["AdminSettings","data class AdminSettings(val bootstrapServer: String, props: Properties? = null)","io.github.nomisRev.kafka.AdminSettings"]},{"name":"data class ConsumerSettings<K, V>(val bootstrapServers: String, val keyDeserializer: Deserializer<K>, val valueDeserializer: Deserializer<V>, val groupId: String, val clientDnsLookup: ClientDnsLookup = ClientDnsLookup.USE_ALL_DNS_IPS, val sessionTimeOut: Duration = Duration.ofMillis(10000), val heartbeatInterval: Duration = Duration.ofMillis(3000), val autoOffsetReset: AutoOffsetReset = AutoOffsetReset.Latest, val partitionAssignmentStrategy: List<Class<*>> = listOf(RangeAssignor::class.java), val metadataMaxAge: Long = (5 * 60 * 1000).toLong(), val enableAutoCommit: Boolean = true, val autoCommitInterval: Duration = Duration.ofMillis(5000), val clientId: String = \"\", val maxPartitionFetchBytes: Int = DEFAULT_MAX_PARTITION_FETCH_BYTES, val sendBuffer: Int = 128 * 1024, val receiveBuffer: Int = 64 * 1024, val fetchMinBytes: Int = 1, val fetchMaxBytes: Int = ConsumerConfig.DEFAULT_FETCH_MAX_BYTES, val fetchMaxWait: Duration = Duration.ofMillis(500), val reconnectBackoff: Duration = Duration.ofMillis(50L), val reconnectBackoffMax: Duration = Duration.ofMillis(1000), val retryBackoff: Duration = Duration.ofMillis(100), val checkCrcs: Boolean = true, val metricsSampleWindow: Duration = Duration.ofMillis(30000), val metricsNumSamples: Int = 2, val metricsRecordingLevel: Sensor.RecordingLevel = Sensor.RecordingLevel.INFO, val metricsReporterClasses: List<Class<*>> = emptyList(), val requestTimeout: Duration = Duration.ofMillis(30000), val defaultApiTimeout: Duration = Duration.ofMillis(60 * 1000), val connectionsMaxIdle: Duration = Duration.ofMillis(9 * 60 * 1000), val interceptorClasses: List<Class<*>> = emptyList(), val maxPollRecords: Int = 500, val maxPollInterval: Duration = Duration.ofMillis(300_000), val excludeInternalTopics: Boolean = ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS, properties: Properties? = null)","description":"io.github.nomisRev.kafka.ConsumerSettings","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/index.html","searchKeys":["ConsumerSettings","data class ConsumerSettings<K, V>(val bootstrapServers: String, val keyDeserializer: Deserializer<K>, val valueDeserializer: Deserializer<V>, val groupId: String, val clientDnsLookup: ClientDnsLookup = ClientDnsLookup.USE_ALL_DNS_IPS, val sessionTimeOut: Duration = Duration.ofMillis(10000), val heartbeatInterval: Duration = Duration.ofMillis(3000), val autoOffsetReset: AutoOffsetReset = AutoOffsetReset.Latest, val partitionAssignmentStrategy: List<Class<*>> = listOf(RangeAssignor::class.java), val metadataMaxAge: Long = (5 * 60 * 1000).toLong(), val enableAutoCommit: Boolean = true, val autoCommitInterval: Duration = Duration.ofMillis(5000), val clientId: String = \"\", val maxPartitionFetchBytes: Int = DEFAULT_MAX_PARTITION_FETCH_BYTES, val sendBuffer: Int = 128 * 1024, val receiveBuffer: Int = 64 * 1024, val fetchMinBytes: Int = 1, val fetchMaxBytes: Int = ConsumerConfig.DEFAULT_FETCH_MAX_BYTES, val fetchMaxWait: Duration = Duration.ofMillis(500), val reconnectBackoff: Duration = Duration.ofMillis(50L), val reconnectBackoffMax: Duration = Duration.ofMillis(1000), val retryBackoff: Duration = Duration.ofMillis(100), val checkCrcs: Boolean = true, val metricsSampleWindow: Duration = Duration.ofMillis(30000), val metricsNumSamples: Int = 2, val metricsRecordingLevel: Sensor.RecordingLevel = Sensor.RecordingLevel.INFO, val metricsReporterClasses: List<Class<*>> = emptyList(), val requestTimeout: Duration = Duration.ofMillis(30000), val defaultApiTimeout: Duration = Duration.ofMillis(60 * 1000), val connectionsMaxIdle: Duration = Duration.ofMillis(9 * 60 * 1000), val interceptorClasses: List<Class<*>> = emptyList(), val maxPollRecords: Int = 500, val maxPollInterval: Duration = Duration.ofMillis(300_000), val excludeInternalTopics: Boolean = ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS, properties: Properties? = null)","io.github.nomisRev.kafka.ConsumerSettings"]},{"name":"data class ProducerSettings<K, V>(val bootstrapServers: String, val keyDeserializer: Serializer<K>, val valueDeserializer: Serializer<V>, val acks: Acks = Acks.One, val other: Properties? = null)","description":"io.github.nomisRev.kafka.ProducerSettings","location":"kotlin-kafka/io.github.nomisRev.kafka/-producer-settings/index.html","searchKeys":["ProducerSettings","data class ProducerSettings<K, V>(val bootstrapServers: String, val keyDeserializer: Serializer<K>, val valueDeserializer: Serializer<V>, val acks: Acks = Acks.One, val other: Properties? = null)","io.github.nomisRev.kafka.ProducerSettings"]},{"name":"enum Acks : Enum<Acks> ","description":"io.github.nomisRev.kafka.Acks","location":"kotlin-kafka/io.github.nomisRev.kafka/-acks/index.html","searchKeys":["Acks","enum Acks : Enum<Acks> ","io.github.nomisRev.kafka.Acks"]},{"name":"enum AutoOffsetReset : Enum<AutoOffsetReset> ","description":"io.github.nomisRev.kafka.AutoOffsetReset","location":"kotlin-kafka/io.github.nomisRev.kafka/-auto-offset-reset/index.html","searchKeys":["AutoOffsetReset","enum AutoOffsetReset : Enum<AutoOffsetReset> ","io.github.nomisRev.kafka.AutoOffsetReset"]},{"name":"fun <A : Closeable> A.asFlow(): Flow<A>","description":"io.github.nomisRev.kafka.asFlow","location":"kotlin-kafka/io.github.nomisRev.kafka/as-flow.html","searchKeys":["asFlow","fun <A : Closeable> A.asFlow(): Flow<A>","io.github.nomisRev.kafka.asFlow"]},{"name":"fun <A, B> Deserializer<A>.map(f: (A) -> B): Deserializer<B>","description":"io.github.nomisRev.kafka.map","location":"kotlin-kafka/io.github.nomisRev.kafka/map.html","searchKeys":["map","fun <A, B> Deserializer<A>.map(f: (A) -> B): Deserializer<B>","io.github.nomisRev.kafka.map"]},{"name":"fun <A, B> Serializer<A>.imap(f: (B) -> A): Serializer<B>","description":"io.github.nomisRev.kafka.imap","location":"kotlin-kafka/io.github.nomisRev.kafka/imap.html","searchKeys":["imap","fun <A, B> Serializer<A>.imap(f: (B) -> A): Serializer<B>","io.github.nomisRev.kafka.imap"]},{"name":"fun <K, V> ConsumerRecord<K, V>.offsets(metadata: (record: ConsumerRecord<K, V>) -> String? = null): Map<TopicPartition, OffsetAndMetadata>","description":"io.github.nomisRev.kafka.offsets","location":"kotlin-kafka/io.github.nomisRev.kafka/offsets.html","searchKeys":["offsets","fun <K, V> ConsumerRecord<K, V>.offsets(metadata: (record: ConsumerRecord<K, V>) -> String? = null): Map<TopicPartition, OffsetAndMetadata>","io.github.nomisRev.kafka.offsets"]},{"name":"fun <K, V> ConsumerSettings(bootstrapServers: String, keyDeserializer: Deserializer<K>, valueDeserializer: Deserializer<V>, groupId: String, clientDnsLookup: ClientDnsLookup = ClientDnsLookup.USE_ALL_DNS_IPS, sessionTimeOut: Duration = Duration.ofMillis(10000), heartbeatInterval: Duration = Duration.ofMillis(3000), autoOffsetReset: AutoOffsetReset = AutoOffsetReset.Latest, partitionAssignmentStrategy: List<Class<*>> = listOf(RangeAssignor::class.java), metadataMaxAge: Long = (5 * 60 * 1000).toLong(), enableAutoCommit: Boolean = true, autoCommitInterval: Duration = Duration.ofMillis(5000), clientId: String = \"\", maxPartitionFetchBytes: Int = DEFAULT_MAX_PARTITION_FETCH_BYTES, sendBuffer: Int = 128 * 1024, receiveBuffer: Int = 64 * 1024, fetchMinBytes: Int = 1, fetchMaxBytes: Int = ConsumerConfig.DEFAULT_FETCH_MAX_BYTES, fetchMaxWait: Duration = Duration.ofMillis(500), reconnectBackoff: Duration = Duration.ofMillis(50L), reconnectBackoffMax: Duration = Duration.ofMillis(1000), retryBackoff: Duration = Duration.ofMillis(100), checkCrcs: Boolean = true, metricsSampleWindow: Duration = Duration.ofMillis(30000), metricsNumSamples: Int = 2, metricsRecordingLevel: Sensor.RecordingLevel = Sensor.RecordingLevel.INFO, metricsReporterClasses: List<Class<*>> = emptyList(), requestTimeout: Duration = Duration.ofMillis(30000), defaultApiTimeout: Duration = Duration.ofMillis(60 * 1000), connectionsMaxIdle: Duration = Duration.ofMillis(9 * 60 * 1000), interceptorClasses: List<Class<*>> = emptyList(), maxPollRecords: Int = 500, maxPollInterval: Duration = Duration.ofMillis(300_000), excludeInternalTopics: Boolean = ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS, properties: Properties? = null)","description":"io.github.nomisRev.kafka.ConsumerSettings.ConsumerSettings","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/-consumer-settings.html","searchKeys":["ConsumerSettings","fun <K, V> ConsumerSettings(bootstrapServers: String, keyDeserializer: Deserializer<K>, valueDeserializer: Deserializer<V>, groupId: String, clientDnsLookup: ClientDnsLookup = ClientDnsLookup.USE_ALL_DNS_IPS, sessionTimeOut: Duration = Duration.ofMillis(10000), heartbeatInterval: Duration = Duration.ofMillis(3000), autoOffsetReset: AutoOffsetReset = AutoOffsetReset.Latest, partitionAssignmentStrategy: List<Class<*>> = listOf(RangeAssignor::class.java), metadataMaxAge: Long = (5 * 60 * 1000).toLong(), enableAutoCommit: Boolean = true, autoCommitInterval: Duration = Duration.ofMillis(5000), clientId: String = \"\", maxPartitionFetchBytes: Int = DEFAULT_MAX_PARTITION_FETCH_BYTES, sendBuffer: Int = 128 * 1024, receiveBuffer: Int = 64 * 1024, fetchMinBytes: Int = 1, fetchMaxBytes: Int = ConsumerConfig.DEFAULT_FETCH_MAX_BYTES, fetchMaxWait: Duration = Duration.ofMillis(500), reconnectBackoff: Duration = Duration.ofMillis(50L), reconnectBackoffMax: Duration = Duration.ofMillis(1000), retryBackoff: Duration = Duration.ofMillis(100), checkCrcs: Boolean = true, metricsSampleWindow: Duration = Duration.ofMillis(30000), metricsNumSamples: Int = 2, metricsRecordingLevel: Sensor.RecordingLevel = Sensor.RecordingLevel.INFO, metricsReporterClasses: List<Class<*>> = emptyList(), requestTimeout: Duration = Duration.ofMillis(30000), defaultApiTimeout: Duration = Duration.ofMillis(60 * 1000), connectionsMaxIdle: Duration = Duration.ofMillis(9 * 60 * 1000), interceptorClasses: List<Class<*>> = emptyList(), maxPollRecords: Int = 500, maxPollInterval: Duration = Duration.ofMillis(300_000), excludeInternalTopics: Boolean = ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS, properties: Properties? = null)","io.github.nomisRev.kafka.ConsumerSettings.ConsumerSettings"]},{"name":"fun <K, V> Flow<ConsumerRecord<K, V>>.commitBatchWithin(settings: ConsumerSettings<K, V>, count: Int, duration: Duration, metadata: (record: ConsumerRecord<K, V>) -> String? = null): Flow<Unit>","description":"io.github.nomisRev.kafka.commitBatchWithin","location":"kotlin-kafka/io.github.nomisRev.kafka/commit-batch-within.html","searchKeys":["commitBatchWithin","fun <K, V> Flow<ConsumerRecord<K, V>>.commitBatchWithin(settings: ConsumerSettings<K, V>, count: Int, duration: Duration, metadata: (record: ConsumerRecord<K, V>) -> String? = null): Flow<Unit>","io.github.nomisRev.kafka.commitBatchWithin"]},{"name":"fun <K, V> Flow<ConsumerRecords<K, V>>.commitBatchWithin(settings: ConsumerSettings<K, V>, count: Int, duration: Duration, metadata: (record: ConsumerRecord<K, V>) -> String? = null): Flow<Map<TopicPartition, OffsetAndMetadata>>","description":"io.github.nomisRev.kafka.commitBatchWithin","location":"kotlin-kafka/io.github.nomisRev.kafka/commit-batch-within.html","searchKeys":["commitBatchWithin","fun <K, V> Flow<ConsumerRecords<K, V>>.commitBatchWithin(settings: ConsumerSettings<K, V>, count: Int, duration: Duration, metadata: (record: ConsumerRecord<K, V>) -> String? = null): Flow<Map<TopicPartition, OffsetAndMetadata>>","io.github.nomisRev.kafka.commitBatchWithin"]},{"name":"fun <K, V> Flow<KafkaConsumer<K, V>>.subscribeTo(name: String, dispatcher: CoroutineDispatcher = IO, listener: ConsumerRebalanceListener = NoOpConsumerRebalanceListener(), timeout: Duration = 500.milliseconds): Flow<ConsumerRecord<K, V>>","description":"io.github.nomisRev.kafka.subscribeTo","location":"kotlin-kafka/io.github.nomisRev.kafka/subscribe-to.html","searchKeys":["subscribeTo","fun <K, V> Flow<KafkaConsumer<K, V>>.subscribeTo(name: String, dispatcher: CoroutineDispatcher = IO, listener: ConsumerRebalanceListener = NoOpConsumerRebalanceListener(), timeout: Duration = 500.milliseconds): Flow<ConsumerRecord<K, V>>","io.github.nomisRev.kafka.subscribeTo"]},{"name":"fun <K, V> Iterable<ConsumerRecord<K, V>>.offsets(metadata: (record: ConsumerRecord<K, V>) -> String? = null): Map<TopicPartition, OffsetAndMetadata>","description":"io.github.nomisRev.kafka.offsets","location":"kotlin-kafka/io.github.nomisRev.kafka/offsets.html","searchKeys":["offsets","fun <K, V> Iterable<ConsumerRecord<K, V>>.offsets(metadata: (record: ConsumerRecord<K, V>) -> String? = null): Map<TopicPartition, OffsetAndMetadata>","io.github.nomisRev.kafka.offsets"]},{"name":"fun <K, V> KafkaConsumer(settings: ConsumerSettings<K, V>): KafkaConsumer<K, V>","description":"io.github.nomisRev.kafka.KafkaConsumer","location":"kotlin-kafka/io.github.nomisRev.kafka/-kafka-consumer.html","searchKeys":["KafkaConsumer","fun <K, V> KafkaConsumer(settings: ConsumerSettings<K, V>): KafkaConsumer<K, V>","io.github.nomisRev.kafka.KafkaConsumer"]},{"name":"fun <K, V> KafkaConsumer<K, V>.subscribeTo(name: String, dispatcher: CoroutineDispatcher = IO, listener: ConsumerRebalanceListener = NoOpConsumerRebalanceListener(), timeout: Duration = 500.milliseconds): Flow<ConsumerRecord<K, V>>","description":"io.github.nomisRev.kafka.subscribeTo","location":"kotlin-kafka/io.github.nomisRev.kafka/subscribe-to.html","searchKeys":["subscribeTo","fun <K, V> KafkaConsumer<K, V>.subscribeTo(name: String, dispatcher: CoroutineDispatcher = IO, listener: ConsumerRebalanceListener = NoOpConsumerRebalanceListener(), timeout: Duration = 500.milliseconds): Flow<ConsumerRecord<K, V>>","io.github.nomisRev.kafka.subscribeTo"]},{"name":"fun <K, V> KafkaProducer(props: Properties, keyDeserializer: Serializer<K>, valueDeserializer: Serializer<V>): KafkaProducer<K, V>","description":"io.github.nomisRev.kafka.KafkaProducer","location":"kotlin-kafka/io.github.nomisRev.kafka/-kafka-producer.html","searchKeys":["KafkaProducer","fun <K, V> KafkaProducer(props: Properties, keyDeserializer: Serializer<K>, valueDeserializer: Serializer<V>): KafkaProducer<K, V>","io.github.nomisRev.kafka.KafkaProducer"]},{"name":"fun <K, V> List<ConsumerRecords<K, V>>.offsets(metadata: (record: ConsumerRecord<K, V>) -> String? = null): Map<TopicPartition, OffsetAndMetadata>","description":"io.github.nomisRev.kafka.offsets","location":"kotlin-kafka/io.github.nomisRev.kafka/offsets.html","searchKeys":["offsets","fun <K, V> List<ConsumerRecords<K, V>>.offsets(metadata: (record: ConsumerRecord<K, V>) -> String? = null): Map<TopicPartition, OffsetAndMetadata>","io.github.nomisRev.kafka.offsets"]},{"name":"fun <K, V> ProducerSettings(bootstrapServers: String, keyDeserializer: Serializer<K>, valueDeserializer: Serializer<V>, acks: Acks = Acks.One, other: Properties? = null)","description":"io.github.nomisRev.kafka.ProducerSettings.ProducerSettings","location":"kotlin-kafka/io.github.nomisRev.kafka/-producer-settings/-producer-settings.html","searchKeys":["ProducerSettings","fun <K, V> ProducerSettings(bootstrapServers: String, keyDeserializer: Serializer<K>, valueDeserializer: Serializer<V>, acks: Acks = Acks.One, other: Properties? = null)","io.github.nomisRev.kafka.ProducerSettings.ProducerSettings"]},{"name":"fun <K, V> kafkaConsumer(settings: ConsumerSettings<K, V>): Flow<KafkaConsumer<K, V>>","description":"io.github.nomisRev.kafka.kafkaConsumer","location":"kotlin-kafka/io.github.nomisRev.kafka/kafka-consumer.html","searchKeys":["kafkaConsumer","fun <K, V> kafkaConsumer(settings: ConsumerSettings<K, V>): Flow<KafkaConsumer<K, V>>","io.github.nomisRev.kafka.kafkaConsumer"]},{"name":"fun <K, V> kafkaProducer(props: Properties, keyDeserializer: Serializer<K>, valueDeserializer: Serializer<V>): Flow<KafkaProducer<K, V>>","description":"io.github.nomisRev.kafka.kafkaProducer","location":"kotlin-kafka/io.github.nomisRev.kafka/kafka-producer.html","searchKeys":["kafkaProducer","fun <K, V> kafkaProducer(props: Properties, keyDeserializer: Serializer<K>, valueDeserializer: Serializer<V>): Flow<KafkaProducer<K, V>>","io.github.nomisRev.kafka.kafkaProducer"]},{"name":"fun <T> KafkaFuture<T>.asDeferred(): Deferred<T>","description":"io.github.nomisRev.kafka.asDeferred","location":"kotlin-kafka/io.github.nomisRev.kafka/as-deferred.html","searchKeys":["asDeferred","fun <T> KafkaFuture<T>.asDeferred(): Deferred<T>","io.github.nomisRev.kafka.asDeferred"]},{"name":"fun Admin(settings: AdminSettings): Admin","description":"io.github.nomisRev.kafka.Admin","location":"kotlin-kafka/io.github.nomisRev.kafka/-admin.html","searchKeys":["Admin","fun Admin(settings: AdminSettings): Admin","io.github.nomisRev.kafka.Admin"]},{"name":"fun AdminSettings(bootstrapServer: String, props: Properties? = null)","description":"io.github.nomisRev.kafka.AdminSettings.AdminSettings","location":"kotlin-kafka/io.github.nomisRev.kafka/-admin-settings/-admin-settings.html","searchKeys":["AdminSettings","fun AdminSettings(bootstrapServer: String, props: Properties? = null)","io.github.nomisRev.kafka.AdminSettings.AdminSettings"]},{"name":"fun kafkaProducer(): Flow<KafkaProducer<K, V>>","description":"io.github.nomisRev.kafka.ProducerSettings.kafkaProducer","location":"kotlin-kafka/io.github.nomisRev.kafka/-producer-settings/kafka-producer.html","searchKeys":["kafkaProducer","fun kafkaProducer(): Flow<KafkaProducer<K, V>>","io.github.nomisRev.kafka.ProducerSettings.kafkaProducer"]},{"name":"fun properties(): Properties","description":"io.github.nomisRev.kafka.AdminSettings.properties","location":"kotlin-kafka/io.github.nomisRev.kafka/-admin-settings/properties.html","searchKeys":["properties","fun properties(): Properties","io.github.nomisRev.kafka.AdminSettings.properties"]},{"name":"fun properties(): Properties","description":"io.github.nomisRev.kafka.ConsumerSettings.properties","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/properties.html","searchKeys":["properties","fun properties(): Properties","io.github.nomisRev.kafka.ConsumerSettings.properties"]},{"name":"fun properties(): Properties","description":"io.github.nomisRev.kafka.ProducerSettings.properties","location":"kotlin-kafka/io.github.nomisRev.kafka/-producer-settings/properties.html","searchKeys":["properties","fun properties(): Properties","io.github.nomisRev.kafka.ProducerSettings.properties"]},{"name":"object NothingDeserializer : Deserializer<Nothing> ","description":"io.github.nomisRev.kafka.NothingDeserializer","location":"kotlin-kafka/io.github.nomisRev.kafka/-nothing-deserializer/index.html","searchKeys":["NothingDeserializer","object NothingDeserializer : Deserializer<Nothing> ","io.github.nomisRev.kafka.NothingDeserializer"]},{"name":"object NothingSerializer : Serializer<Nothing> ","description":"io.github.nomisRev.kafka.NothingSerializer","location":"kotlin-kafka/io.github.nomisRev.kafka/-nothing-serializer/index.html","searchKeys":["NothingSerializer","object NothingSerializer : Serializer<Nothing> ","io.github.nomisRev.kafka.NothingSerializer"]},{"name":"open override fun close()","description":"io.github.nomisRev.kafka.NothingDeserializer.close","location":"kotlin-kafka/io.github.nomisRev.kafka/-nothing-deserializer/close.html","searchKeys":["close","open override fun close()","io.github.nomisRev.kafka.NothingDeserializer.close"]},{"name":"open override fun close()","description":"io.github.nomisRev.kafka.NothingSerializer.close","location":"kotlin-kafka/io.github.nomisRev.kafka/-nothing-serializer/close.html","searchKeys":["close","open override fun close()","io.github.nomisRev.kafka.NothingSerializer.close"]},{"name":"open override fun configure(configs: MutableMap<String, *>?, isKey: Boolean)","description":"io.github.nomisRev.kafka.NothingDeserializer.configure","location":"kotlin-kafka/io.github.nomisRev.kafka/-nothing-deserializer/configure.html","searchKeys":["configure","open override fun configure(configs: MutableMap<String, *>?, isKey: Boolean)","io.github.nomisRev.kafka.NothingDeserializer.configure"]},{"name":"open override fun configure(configs: MutableMap<String, *>?, isKey: Boolean)","description":"io.github.nomisRev.kafka.NothingSerializer.configure","location":"kotlin-kafka/io.github.nomisRev.kafka/-nothing-serializer/configure.html","searchKeys":["configure","open override fun configure(configs: MutableMap<String, *>?, isKey: Boolean)","io.github.nomisRev.kafka.NothingSerializer.configure"]},{"name":"open override fun deserialize(topic: String?, data: ByteArray?): Nothing","description":"io.github.nomisRev.kafka.NothingDeserializer.deserialize","location":"kotlin-kafka/io.github.nomisRev.kafka/-nothing-deserializer/deserialize.html","searchKeys":["deserialize","open override fun deserialize(topic: String?, data: ByteArray?): Nothing","io.github.nomisRev.kafka.NothingDeserializer.deserialize"]},{"name":"open override fun serialize(topic: String?, data: Nothing?): ByteArray","description":"io.github.nomisRev.kafka.NothingSerializer.serialize","location":"kotlin-kafka/io.github.nomisRev.kafka/-nothing-serializer/serialize.html","searchKeys":["serialize","open override fun serialize(topic: String?, data: Nothing?): ByteArray","io.github.nomisRev.kafka.NothingSerializer.serialize"]},{"name":"operator fun <K, V> ConsumerRecord<K, V>.component1(): K","description":"io.github.nomisRev.kafka.component1","location":"kotlin-kafka/io.github.nomisRev.kafka/component1.html","searchKeys":["component1","operator fun <K, V> ConsumerRecord<K, V>.component1(): K","io.github.nomisRev.kafka.component1"]},{"name":"operator fun <K, V> ConsumerRecord<K, V>.component2(): V","description":"io.github.nomisRev.kafka.component2","location":"kotlin-kafka/io.github.nomisRev.kafka/component2.html","searchKeys":["component2","operator fun <K, V> ConsumerRecord<K, V>.component2(): V","io.github.nomisRev.kafka.component2"]},{"name":"suspend fun <A, B> Flow<ProducerRecord<A, B>>.produce(settings: ProducerSettings<A, B>): Flow<RecordMetadata>","description":"io.github.nomisRev.kafka.produce","location":"kotlin-kafka/io.github.nomisRev.kafka/produce.html","searchKeys":["produce","suspend fun <A, B> Flow<ProducerRecord<A, B>>.produce(settings: ProducerSettings<A, B>): Flow<RecordMetadata>","io.github.nomisRev.kafka.produce"]},{"name":"suspend fun <A, B> KafkaProducer<A, B>.sendAwait(record: ProducerRecord<A, B>): RecordMetadata","description":"io.github.nomisRev.kafka.sendAwait","location":"kotlin-kafka/io.github.nomisRev.kafka/send-await.html","searchKeys":["sendAwait","suspend fun <A, B> KafkaProducer<A, B>.sendAwait(record: ProducerRecord<A, B>): RecordMetadata","io.github.nomisRev.kafka.sendAwait"]},{"name":"suspend fun <K, V> KafkaConsumer<K, V>.commitAwait(offsets: Map<TopicPartition, OffsetAndMetadata>): Map<TopicPartition, OffsetAndMetadata>","description":"io.github.nomisRev.kafka.commitAwait","location":"kotlin-kafka/io.github.nomisRev.kafka/commit-await.html","searchKeys":["commitAwait","suspend fun <K, V> KafkaConsumer<K, V>.commitAwait(offsets: Map<TopicPartition, OffsetAndMetadata>): Map<TopicPartition, OffsetAndMetadata>","io.github.nomisRev.kafka.commitAwait"]},{"name":"suspend fun <T> KafkaFuture<T>.await(): T","description":"io.github.nomisRev.kafka.await","location":"kotlin-kafka/io.github.nomisRev.kafka/await.html","searchKeys":["await","suspend fun <T> KafkaFuture<T>.await(): T","io.github.nomisRev.kafka.await"]},{"name":"suspend fun Admin.createTopic(topic: Iterable<NewTopic>, option: CreateTopicsOptions = CreateTopicsOptions())","description":"io.github.nomisRev.kafka.createTopic","location":"kotlin-kafka/io.github.nomisRev.kafka/create-topic.html","searchKeys":["createTopic","suspend fun Admin.createTopic(topic: Iterable<NewTopic>, option: CreateTopicsOptions = CreateTopicsOptions())","io.github.nomisRev.kafka.createTopic"]},{"name":"suspend fun Admin.createTopic(topic: NewTopic, option: CreateTopicsOptions = CreateTopicsOptions())","description":"io.github.nomisRev.kafka.createTopic","location":"kotlin-kafka/io.github.nomisRev.kafka/create-topic.html","searchKeys":["createTopic","suspend fun Admin.createTopic(topic: NewTopic, option: CreateTopicsOptions = CreateTopicsOptions())","io.github.nomisRev.kafka.createTopic"]},{"name":"suspend fun Admin.deleteTopic(name: String, options: DeleteTopicsOptions = DeleteTopicsOptions())","description":"io.github.nomisRev.kafka.deleteTopic","location":"kotlin-kafka/io.github.nomisRev.kafka/delete-topic.html","searchKeys":["deleteTopic","suspend fun Admin.deleteTopic(name: String, options: DeleteTopicsOptions = DeleteTopicsOptions())","io.github.nomisRev.kafka.deleteTopic"]},{"name":"suspend fun Admin.describeTopic(name: String, options: DescribeTopicsOptions = DescribeTopicsOptions()): TopicDescription?","description":"io.github.nomisRev.kafka.describeTopic","location":"kotlin-kafka/io.github.nomisRev.kafka/describe-topic.html","searchKeys":["describeTopic","suspend fun Admin.describeTopic(name: String, options: DescribeTopicsOptions = DescribeTopicsOptions()): TopicDescription?","io.github.nomisRev.kafka.describeTopic"]},{"name":"suspend fun Admin.topicExists(topic: NewTopic, listTopicsOptions: ListTopicsOptions = ListTopicsOptions()): Boolean","description":"io.github.nomisRev.kafka.topicExists","location":"kotlin-kafka/io.github.nomisRev.kafka/topic-exists.html","searchKeys":["topicExists","suspend fun Admin.topicExists(topic: NewTopic, listTopicsOptions: ListTopicsOptions = ListTopicsOptions()): Boolean","io.github.nomisRev.kafka.topicExists"]},{"name":"suspend fun CreateTopicsResult.await()","description":"io.github.nomisRev.kafka.await","location":"kotlin-kafka/io.github.nomisRev.kafka/await.html","searchKeys":["await","suspend fun CreateTopicsResult.await()","io.github.nomisRev.kafka.await"]},{"name":"suspend fun DeleteTopicsResult.await()","description":"io.github.nomisRev.kafka.await","location":"kotlin-kafka/io.github.nomisRev.kafka/await.html","searchKeys":["await","suspend fun DeleteTopicsResult.await()","io.github.nomisRev.kafka.await"]},{"name":"val acks: Acks","description":"io.github.nomisRev.kafka.ProducerSettings.acks","location":"kotlin-kafka/io.github.nomisRev.kafka/-producer-settings/acks.html","searchKeys":["acks","val acks: Acks","io.github.nomisRev.kafka.ProducerSettings.acks"]},{"name":"val autoCommitInterval: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.autoCommitInterval","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/auto-commit-interval.html","searchKeys":["autoCommitInterval","val autoCommitInterval: Duration","io.github.nomisRev.kafka.ConsumerSettings.autoCommitInterval"]},{"name":"val autoOffsetReset: AutoOffsetReset","description":"io.github.nomisRev.kafka.ConsumerSettings.autoOffsetReset","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/auto-offset-reset.html","searchKeys":["autoOffsetReset","val autoOffsetReset: AutoOffsetReset","io.github.nomisRev.kafka.ConsumerSettings.autoOffsetReset"]},{"name":"val bootstrapServer: String","description":"io.github.nomisRev.kafka.AdminSettings.bootstrapServer","location":"kotlin-kafka/io.github.nomisRev.kafka/-admin-settings/bootstrap-server.html","searchKeys":["bootstrapServer","val bootstrapServer: String","io.github.nomisRev.kafka.AdminSettings.bootstrapServer"]},{"name":"val bootstrapServers: String","description":"io.github.nomisRev.kafka.ConsumerSettings.bootstrapServers","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/bootstrap-servers.html","searchKeys":["bootstrapServers","val bootstrapServers: String","io.github.nomisRev.kafka.ConsumerSettings.bootstrapServers"]},{"name":"val bootstrapServers: String","description":"io.github.nomisRev.kafka.ProducerSettings.bootstrapServers","location":"kotlin-kafka/io.github.nomisRev.kafka/-producer-settings/bootstrap-servers.html","searchKeys":["bootstrapServers","val bootstrapServers: String","io.github.nomisRev.kafka.ProducerSettings.bootstrapServers"]},{"name":"val checkCrcs: Boolean = true","description":"io.github.nomisRev.kafka.ConsumerSettings.checkCrcs","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/check-crcs.html","searchKeys":["checkCrcs","val checkCrcs: Boolean = true","io.github.nomisRev.kafka.ConsumerSettings.checkCrcs"]},{"name":"val clientDnsLookup: ClientDnsLookup","description":"io.github.nomisRev.kafka.ConsumerSettings.clientDnsLookup","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/client-dns-lookup.html","searchKeys":["clientDnsLookup","val clientDnsLookup: ClientDnsLookup","io.github.nomisRev.kafka.ConsumerSettings.clientDnsLookup"]},{"name":"val clientId: String","description":"io.github.nomisRev.kafka.ConsumerSettings.clientId","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/client-id.html","searchKeys":["clientId","val clientId: String","io.github.nomisRev.kafka.ConsumerSettings.clientId"]},{"name":"val connectionsMaxIdle: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.connectionsMaxIdle","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/connections-max-idle.html","searchKeys":["connectionsMaxIdle","val connectionsMaxIdle: Duration","io.github.nomisRev.kafka.ConsumerSettings.connectionsMaxIdle"]},{"name":"val defaultApiTimeout: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.defaultApiTimeout","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/default-api-timeout.html","searchKeys":["defaultApiTimeout","val defaultApiTimeout: Duration","io.github.nomisRev.kafka.ConsumerSettings.defaultApiTimeout"]},{"name":"val enableAutoCommit: Boolean = true","description":"io.github.nomisRev.kafka.ConsumerSettings.enableAutoCommit","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/enable-auto-commit.html","searchKeys":["enableAutoCommit","val enableAutoCommit: Boolean = true","io.github.nomisRev.kafka.ConsumerSettings.enableAutoCommit"]},{"name":"val excludeInternalTopics: Boolean","description":"io.github.nomisRev.kafka.ConsumerSettings.excludeInternalTopics","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/exclude-internal-topics.html","searchKeys":["excludeInternalTopics","val excludeInternalTopics: Boolean","io.github.nomisRev.kafka.ConsumerSettings.excludeInternalTopics"]},{"name":"val fetchMaxBytes: Int","description":"io.github.nomisRev.kafka.ConsumerSettings.fetchMaxBytes","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/fetch-max-bytes.html","searchKeys":["fetchMaxBytes","val fetchMaxBytes: Int","io.github.nomisRev.kafka.ConsumerSettings.fetchMaxBytes"]},{"name":"val fetchMaxWait: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.fetchMaxWait","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/fetch-max-wait.html","searchKeys":["fetchMaxWait","val fetchMaxWait: Duration","io.github.nomisRev.kafka.ConsumerSettings.fetchMaxWait"]},{"name":"val fetchMinBytes: Int = 1","description":"io.github.nomisRev.kafka.ConsumerSettings.fetchMinBytes","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/fetch-min-bytes.html","searchKeys":["fetchMinBytes","val fetchMinBytes: Int = 1","io.github.nomisRev.kafka.ConsumerSettings.fetchMinBytes"]},{"name":"val groupId: String","description":"io.github.nomisRev.kafka.ConsumerSettings.groupId","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/group-id.html","searchKeys":["groupId","val groupId: String","io.github.nomisRev.kafka.ConsumerSettings.groupId"]},{"name":"val heartbeatInterval: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.heartbeatInterval","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/heartbeat-interval.html","searchKeys":["heartbeatInterval","val heartbeatInterval: Duration","io.github.nomisRev.kafka.ConsumerSettings.heartbeatInterval"]},{"name":"val interceptorClasses: List<Class<*>>","description":"io.github.nomisRev.kafka.ConsumerSettings.interceptorClasses","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/interceptor-classes.html","searchKeys":["interceptorClasses","val interceptorClasses: List<Class<*>>","io.github.nomisRev.kafka.ConsumerSettings.interceptorClasses"]},{"name":"val keyDeserializer: Deserializer<K>","description":"io.github.nomisRev.kafka.ConsumerSettings.keyDeserializer","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/key-deserializer.html","searchKeys":["keyDeserializer","val keyDeserializer: Deserializer<K>","io.github.nomisRev.kafka.ConsumerSettings.keyDeserializer"]},{"name":"val keyDeserializer: Serializer<K>","description":"io.github.nomisRev.kafka.ProducerSettings.keyDeserializer","location":"kotlin-kafka/io.github.nomisRev.kafka/-producer-settings/key-deserializer.html","searchKeys":["keyDeserializer","val keyDeserializer: Serializer<K>","io.github.nomisRev.kafka.ProducerSettings.keyDeserializer"]},{"name":"val maxPartitionFetchBytes: Int","description":"io.github.nomisRev.kafka.ConsumerSettings.maxPartitionFetchBytes","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/max-partition-fetch-bytes.html","searchKeys":["maxPartitionFetchBytes","val maxPartitionFetchBytes: Int","io.github.nomisRev.kafka.ConsumerSettings.maxPartitionFetchBytes"]},{"name":"val maxPollInterval: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.maxPollInterval","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/max-poll-interval.html","searchKeys":["maxPollInterval","val maxPollInterval: Duration","io.github.nomisRev.kafka.ConsumerSettings.maxPollInterval"]},{"name":"val maxPollRecords: Int = 500","description":"io.github.nomisRev.kafka.ConsumerSettings.maxPollRecords","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/max-poll-records.html","searchKeys":["maxPollRecords","val maxPollRecords: Int = 500","io.github.nomisRev.kafka.ConsumerSettings.maxPollRecords"]},{"name":"val metadataMaxAge: Long","description":"io.github.nomisRev.kafka.ConsumerSettings.metadataMaxAge","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/metadata-max-age.html","searchKeys":["metadataMaxAge","val metadataMaxAge: Long","io.github.nomisRev.kafka.ConsumerSettings.metadataMaxAge"]},{"name":"val metricsNumSamples: Int = 2","description":"io.github.nomisRev.kafka.ConsumerSettings.metricsNumSamples","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/metrics-num-samples.html","searchKeys":["metricsNumSamples","val metricsNumSamples: Int = 2","io.github.nomisRev.kafka.ConsumerSettings.metricsNumSamples"]},{"name":"val metricsRecordingLevel: Sensor.RecordingLevel","description":"io.github.nomisRev.kafka.ConsumerSettings.metricsRecordingLevel","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/metrics-recording-level.html","searchKeys":["metricsRecordingLevel","val metricsRecordingLevel: Sensor.RecordingLevel","io.github.nomisRev.kafka.ConsumerSettings.metricsRecordingLevel"]},{"name":"val metricsReporterClasses: List<Class<*>>","description":"io.github.nomisRev.kafka.ConsumerSettings.metricsReporterClasses","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/metrics-reporter-classes.html","searchKeys":["metricsReporterClasses","val metricsReporterClasses: List<Class<*>>","io.github.nomisRev.kafka.ConsumerSettings.metricsReporterClasses"]},{"name":"val metricsSampleWindow: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.metricsSampleWindow","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/metrics-sample-window.html","searchKeys":["metricsSampleWindow","val metricsSampleWindow: Duration","io.github.nomisRev.kafka.ConsumerSettings.metricsSampleWindow"]},{"name":"val other: Properties? = null","description":"io.github.nomisRev.kafka.ProducerSettings.other","location":"kotlin-kafka/io.github.nomisRev.kafka/-producer-settings/other.html","searchKeys":["other","val other: Properties? = null","io.github.nomisRev.kafka.ProducerSettings.other"]},{"name":"val partitionAssignmentStrategy: List<Class<*>>","description":"io.github.nomisRev.kafka.ConsumerSettings.partitionAssignmentStrategy","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/partition-assignment-strategy.html","searchKeys":["partitionAssignmentStrategy","val partitionAssignmentStrategy: List<Class<*>>","io.github.nomisRev.kafka.ConsumerSettings.partitionAssignmentStrategy"]},{"name":"val receiveBuffer: Int","description":"io.github.nomisRev.kafka.ConsumerSettings.receiveBuffer","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/receive-buffer.html","searchKeys":["receiveBuffer","val receiveBuffer: Int","io.github.nomisRev.kafka.ConsumerSettings.receiveBuffer"]},{"name":"val reconnectBackoff: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.reconnectBackoff","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/reconnect-backoff.html","searchKeys":["reconnectBackoff","val reconnectBackoff: Duration","io.github.nomisRev.kafka.ConsumerSettings.reconnectBackoff"]},{"name":"val reconnectBackoffMax: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.reconnectBackoffMax","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/reconnect-backoff-max.html","searchKeys":["reconnectBackoffMax","val reconnectBackoffMax: Duration","io.github.nomisRev.kafka.ConsumerSettings.reconnectBackoffMax"]},{"name":"val requestTimeout: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.requestTimeout","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/request-timeout.html","searchKeys":["requestTimeout","val requestTimeout: Duration","io.github.nomisRev.kafka.ConsumerSettings.requestTimeout"]},{"name":"val retryBackoff: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.retryBackoff","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/retry-backoff.html","searchKeys":["retryBackoff","val retryBackoff: Duration","io.github.nomisRev.kafka.ConsumerSettings.retryBackoff"]},{"name":"val sendBuffer: Int","description":"io.github.nomisRev.kafka.ConsumerSettings.sendBuffer","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/send-buffer.html","searchKeys":["sendBuffer","val sendBuffer: Int","io.github.nomisRev.kafka.ConsumerSettings.sendBuffer"]},{"name":"val sessionTimeOut: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.sessionTimeOut","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/session-time-out.html","searchKeys":["sessionTimeOut","val sessionTimeOut: Duration","io.github.nomisRev.kafka.ConsumerSettings.sessionTimeOut"]},{"name":"val value: String","description":"io.github.nomisRev.kafka.Acks.value","location":"kotlin-kafka/io.github.nomisRev.kafka/-acks/value.html","searchKeys":["value","val value: String","io.github.nomisRev.kafka.Acks.value"]},{"name":"val value: String","description":"io.github.nomisRev.kafka.AutoOffsetReset.value","location":"kotlin-kafka/io.github.nomisRev.kafka/-auto-offset-reset/value.html","searchKeys":["value","val value: String","io.github.nomisRev.kafka.AutoOffsetReset.value"]},{"name":"val valueDeserializer: Deserializer<V>","description":"io.github.nomisRev.kafka.ConsumerSettings.valueDeserializer","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/value-deserializer.html","searchKeys":["valueDeserializer","val valueDeserializer: Deserializer<V>","io.github.nomisRev.kafka.ConsumerSettings.valueDeserializer"]},{"name":"val valueDeserializer: Serializer<V>","description":"io.github.nomisRev.kafka.ProducerSettings.valueDeserializer","location":"kotlin-kafka/io.github.nomisRev.kafka/-producer-settings/value-deserializer.html","searchKeys":["valueDeserializer","val valueDeserializer: Serializer<V>","io.github.nomisRev.kafka.ProducerSettings.valueDeserializer"]}]
